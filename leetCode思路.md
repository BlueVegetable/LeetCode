[toc]

#leetCode各个题目思路
## 007整数反转
>题目描述
>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。

题目注意问题：
数据越界：如果32位的数据反转之后超过Integer.MAX_VALUE，那么需要返回0.
判断方法：用Integer.parseInt()函数抛出异常来判断反转后的字符串所构成的数字越界。

## 098 验证二叉搜索树
>给定一个二叉树，判断其是否是一个有效的二叉搜索树。

题目注意问题：二叉搜索树中序遍历之后，得到的是有序的递增数组。如果递增数组有两个数据相同，则不是二叉搜索树

## 042接雨水
1. 首先，找到能存水的左边界索引left和右边界索引right。
>对于左边界索引left是从数组头到数组尾方向看，第一次出现下降趋势的那个索引的位置。
>对于右边界索引right是从数组尾到数组头方向看，第一次出现下降趋势的那个索引的位置。

2. 记录左边界和右边界的高度，分别记作leftHeight和rightHeight。显然，雨水数是由较低的边界所决定的。
>如果leftHeight小于等于rightHeight
>
>如果此时满足left < right，说明左右边界还没有重合，尝试着令left加1。如果left位置能够存储雨水，则更新结果的值。如果left位置不能存储雨水，说明left位置的高度大于等于leftHeight，这时我们应该进入下一轮循环，更新leftHeight的值。
>如果leftHeight大于rightHeight
>
>如果此时满足left < right，说明左右边界还没有重合，尝试着令right减1。如果right位置能够存储雨水，则更新结果的值。如果right位置不能存储雨水，说明right位置的高度大于等于rightHeight，这时我们应该进入下一轮循环，更新rightHeight的值。

3. 算法复杂度
时间复杂度是O(n)级别的，空间复杂度是O(1)级别的

## 128 最长连续序列
初始时，Map对应的键集合中包含数组中的所有值，均未被计算过，每个键对应的布尔值为false。

对nums数组中的每一个元素，左指针left取为nums[i] - 1，右指针right取为nums[i] + 1左右依次扩展，每次向左扩展间隔为1，向右扩展间隔也为1，如果发现其左或右边的值在Map对应的键集合中，且未被计算过，且在整数范围内，就令左指针减1或右指针加1，最后right - left - 1即为当前数字nums[i]所对应的最长连续序列长度。

时间复杂度和空间复杂度均为O(n)，其中n为nums数组的大小。

## 1025除数博弈
>首先要明白谁先到N=2谁赢，
>奇数的因数肯定都是奇数，偶数的因数有奇数和偶数，由于最优策略，最后肯定是到N=2的。
>如果N是偶数，爱丽丝只要选奇数，不行就一直选1，那么最后N=2的时候肯定是爱丽丝赢，
>相反的假如N是奇数，因数也是奇数，那么到鲍勃N就是偶数，那么爱丽丝肯定输。
>所以最后只需要判断奇偶就行了。